{"tags":[{"name":"半平面交","permalink":"http://lzy-foenix.github.io/tags/半平面交/","url":"\\async\\tags\\半平面交.json","count":5}],"categories":[{"name":"计算几何","permalink":"http://lzy-foenix.github.io/categories/计算几何/","url":"\\async\\categories\\计算几何.json","count":12}],"url":"\\async\\posts\\2015\\03\\17\\半平面交nlogn方法小结.json","date":1426573721000,"path":{"year":2015,"month":3,"day":17,"name":"半平面交nlogn方法小结"},"title":"半平面交nlogn方法小结","permalink":"http://lzy-foenix.github.io/2015/03/17/半平面交nlogn方法小结/","content":"<hr>\n<a id=\"more\"></a>\n<h3 id=\"题目引入：\"><a href=\"#题目引入：\" class=\"headerlink\" title=\"题目引入：\"></a>题目引入：</h3><p>给你n条直线和L,R,M，求这n条直线与(0,L),(0,R),(M,L),(M,R)所围成的矩形的交集所围成的面积，就是求半平面交。</p>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><p>由于题目数据范围比较亲(s)和(b)，再加上我非常弱，所以我只能又学一遍nlogn的办平面交，首先膜拜一下ZZy大神。<br><a href=\"http://wenku.baidu.com/link?url=UU5hwO-WS1D3LSOi2vk_XpP71EyYAgGHKuM7sWZTw164ooWB0dBv-RLvpz5CRn0lTfaU296Z0415BNBbEmBPrpgUDJdQhK6NNnEQO3LLJ0a\" target=\"_blank\" rel=\"external\">ZZy大神的课件</a><br>nlogn的方法有五步<br>step1：<br>将所有半平面按极角排序，对于极角相同的，选择性的保留一个。O(nlogn)<br>step2:<br>使用一个双端队列(deque)，加入最开始2个半平面。<br>step3:<br>每次考虑一个新的半平面： a.while deque顶端的两个半平面的交点在当前半平面外:删除deque顶端的半平面b.while deque底部的两个半平面的交点在当前半平面外:删除deque底部的半平面c.将新半平面加入deque顶端<br>step4:<br>删除两端多余的半平面。具体方法是： a.while deque顶端的两个半平面的交点在底部半平面外:删除deque顶端的半平面b.while deque底部的两个半平面的交点在顶端半平面外:删除deque底部的半平面重复a,b直到不能删除为止。<br>step5:<br>计算出deque顶端和底部的交点即可。</p>\n<h3 id=\"代码：\"><a href=\"#代码：\" class=\"headerlink\" title=\"代码：\"></a>代码：</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;iostream&gt;</div><div class=\"line\">#include&lt;cstdio&gt;</div><div class=\"line\">#include&lt;cstring&gt;</div><div class=\"line\">#include&lt;algorithm&gt;</div><div class=\"line\">#include&lt;cstdlib&gt;</div><div class=\"line\">#include&lt;cmath&gt;</div><div class=\"line\">#include&lt;queue&gt;</div><div class=\"line\">#define eps 1e-10</div><div class=\"line\">#define zero(a) fabs(a)&lt;eps</div><div class=\"line\">#define MAXN 200005</div><div class=\"line\">using namespace std;</div><div class=\"line\">struct Point&#123;</div><div class=\"line\">    double x,y;</div><div class=\"line\">&#125;p[MAXN*2];</div><div class=\"line\">struct Segment&#123;</div><div class=\"line\">    Point s,e;</div><div class=\"line\">    double angle;</div><div class=\"line\">    void get_angle()&#123;angle=atan2(e.y-s.y,e.x-s.x);&#125;</div><div class=\"line\">&#125;seg[MAXN],deq[MAXN];</div><div class=\"line\">int m,N,U[MAXN],A[MAXN],B[MAXN],C[MAXN],a;</div><div class=\"line\">double L,R,M;</div><div class=\"line\">//叉积为正说明，p2在p0-p1的左侧</div><div class=\"line\">double xmul(Point p0,Point p1,Point p2)&#123;</div><div class=\"line\">\treturn (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</div><div class=\"line\">&#125;</div><div class=\"line\">Point Get_Intersect(Segment s1,Segment s2)&#123;</div><div class=\"line\">\tdouble u=xmul(s1.s,s1.e,s2.s),v=xmul(s1.e,s1.s,s2.e);</div><div class=\"line\">\tPoint t;</div><div class=\"line\">\tt.x=(s2.s.x*v+s2.e.x*u)/(u+v);t.y=(s2.s.y*v+s2.e.y*u)/(u+v);</div><div class=\"line\">\treturn t;</div><div class=\"line\">&#125;</div><div class=\"line\">bool cmp(Segment s1,Segment s2)&#123;</div><div class=\"line\">\t//先按极角排序</div><div class=\"line\">\tif(s1.angle&gt;s2.angle) return true;</div><div class=\"line\">    //极角相等，内侧的在前</div><div class=\"line\">\telse if(zero(s1.angle-s2.angle)&amp;&amp;xmul(s2.s,s2.e,s1.e)&gt;-eps) return true;</div><div class=\"line\">\treturn false;</div><div class=\"line\">&#125;</div><div class=\"line\">void HalfPlaneIntersect(Segment seg[],int n)&#123;</div><div class=\"line\">\tsort(seg,seg+n,cmp);//首先排序 </div><div class=\"line\">\tint tmp=1;</div><div class=\"line\">\tfor(int i=1;i&lt;n;i++)</div><div class=\"line\">\t\tif(!zero(seg[i].angle-seg[tmp-1].angle))//不是极角相同的，由于排了序，</div><div class=\"line\">\t\t//所以只跟最后一个进入的进行比较 </div><div class=\"line\">\t\t\tseg[tmp++]=seg[i];</div><div class=\"line\">\tn=tmp;</div><div class=\"line\">\tdeq[0]=seg[0];deq[1]=seg[1];//deq是双端队列，先将一开始的两个平面压入队列</div><div class=\"line\">\tint head=0,tail=1;</div><div class=\"line\">\tfor(int i=2;i&lt;n;i++)&#123;</div><div class=\"line\">\t\twhile(head&lt;tail&amp;&amp;xmul(seg[i].s,seg[i].e,Get_Intersect(deq[tail],deq[tail-1]))&lt;-eps) tail--;</div><div class=\"line\">\t\t//如果原来双端队列中队尾的两条直线的交点在新直线的外侧，那么就去掉队尾元素 </div><div class=\"line\">\t\twhile(head&lt;tail&amp;&amp;xmul(seg[i].s,seg[i].e,Get_Intersect(deq[head],deq[head+1]))&lt;-eps) head++;</div><div class=\"line\">\t\t//如果原来双端队列中队首的两条直线的交点在新直线的外侧，那么就去掉队首元素 </div><div class=\"line\">\t\tdeq[++tail]=seg[i];//加入新元素</div><div class=\"line\">\t&#125;</div><div class=\"line\">\twhile(head&lt;tail&amp;&amp;xmul(deq[head].s,deq[head].e,Get_Intersect(deq[tail],deq[tail-1]))&lt;-eps) tail--;</div><div class=\"line\">\twhile(head&lt;tail&amp;&amp;xmul(deq[tail].s,deq[tail].e,Get_Intersect(deq[head],deq[head+1]))&lt;-eps) head++;</div><div class=\"line\">\t//判断首位的两条直线，这个貌似不判断也可以，判断也没错</div><div class=\"line\">\tif(head==tail)return;//不存在 </div><div class=\"line\">\tm=0;</div><div class=\"line\">\tfor(int i=head;i&lt;tail;i++)</div><div class=\"line\">\t\tp[m++]=Get_Intersect(deq[i],deq[i+1]);</div><div class=\"line\">\tif(tail&gt;head+1)</div><div class=\"line\">\t\tp[m++]=Get_Intersect(deq[head],deq[tail]);</div><div class=\"line\">&#125;</div><div class=\"line\">double Get_area(Point p[],int &amp;n)&#123;</div><div class=\"line\">\tdouble area=0;</div><div class=\"line\">\tfor(int i=1;i&lt;n-1;i++)</div><div class=\"line\">\t\tarea+=xmul(p[0],p[i],p[i+1]);</div><div class=\"line\">\treturn fabs(area)/2.0;</div><div class=\"line\">&#125;</div><div class=\"line\">int main()&#123;</div><div class=\"line\">\tscanf(\"%d%lf%lf%lf\",&amp;N,&amp;M,&amp;L,&amp;R);</div><div class=\"line\">\tseg[0].s.x=0;seg[0].s.y=L;\tseg[0].e.x=M;seg[0].e.y=L;\tseg[0].get_angle();</div><div class=\"line\">\tseg[1].s.x=M;seg[1].s.y=L;\tseg[1].e.x=M;seg[1].e.y=R;\tseg[1].get_angle();</div><div class=\"line\">\tseg[2].s.x=M;seg[2].s.y=R;\tseg[2].e.x=0;seg[2].e.y=R;\tseg[2].get_angle();</div><div class=\"line\">\tseg[3].s.x=0;seg[3].s.y=R;\tseg[3].e.x=0;seg[3].e.y=L;\tseg[3].get_angle();</div><div class=\"line\">\tchar ch[10];</div><div class=\"line\">\tfor(int i=1;i&lt;=N;i++)scanf(\"%d\",&amp;U[i]),A[i]=(double)(U[i]+1);</div><div class=\"line\">\tfor(int i=1;i&lt;=N;i++)&#123;</div><div class=\"line\">\t\tscanf(\"%s\",ch); B[i]=-1;</div><div class=\"line\">\t\tif(ch[0]=='E')scanf(\"%d\",&amp;a),C[i]=(double)a;</div><div class=\"line\">\t\telse scanf(\"%d\",&amp;a),C[i]=-(double)a;</div><div class=\"line\">\t\tseg[i+3].s.x=0; seg[i+3].s.y=C[i]; seg[i+3].e.x=1000; seg[i+3].e.y=1000*A[i]+C[i];</div><div class=\"line\">\t\tseg[i+3].get_angle();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tHalfPlaneIntersect(seg,N+4);</div><div class=\"line\">\tdouble ans=Get_area(p,m),Tmp=(R-L)*M;</div><div class=\"line\">\tprintf(\"%.4f\\n\",ans/Tmp);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"}